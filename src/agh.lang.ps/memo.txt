■

計画1. 描画パス実装
~~~~~~~~~~~~~~~~~~~
1. 文字列の表示
2. path の再設計
  moveto 要素はなくす
  その他の要素に始点の情報を持たせる。
  線分
  曲線
  閉回路
  
  charpath → P_CHAR
    primitive_show に渡すのと同じ情報を保持する。
    フォント
    開始点
    文字幅
    文字
    (描画時は、charpath のみ textpath 要素で別に描画を実行する。)

  pathbbox
    1. 各要素について bbox を求める。
      ・線分は単純
        現在の座標に変換してから min,min - max,max
      ・曲線は、
        現在の座標に変換してから、
        ベジェ曲線の最大値最小値を求める必要がある。
      ・閉回路演算は、bbox を求める必要はない。
        必ず他の要素の bbox の内側にはいるから。
      ・文字列に関しては、
        取り敢えず、四隅の点についてだけ考慮する事にする。
    2. 逐次各要素から来る bbox を併合して大きな bbox にしていく
      →bbox を併合するよりは、
        それを構成する点をどんどん列挙していって、
        その最小と最大を記録する様にした方が良い。
    
3. Canvas 出力の実装
  SVG で巨大な出力を出すと
  ・Firefox は SVG の解析に時間が掛かって、Firefox 全体の動作が止まるし、
  ・Chrome は一頁当たりのメモリ容量の制限に引っかかるからなのか、計算が最後まで出来ない。
  
  Canvas は vector ではないので、拡大縮小・印刷に対しては綺麗な結果を与えないかも知れないが、
  高速な動作・どのページでも実行出来る、という事を考えればできるだけ速く実装した方が良いであろう。
  
  →実装完了。意外と簡単に終わった。
  ■但し、点線・破線については未対応。そもそも Canvas で primitive に対応していない
    ・直線の点線化は簡単
    ・Bezier 曲線の点線化は式変形すれば分かる。
      弧長を厳密な形で計算出来るかは分からない。
    ・文字輪郭の点線化は難しい (本当に可能なのか?)
    

4. arc を実装するという事

  x y r angle1 angle2 arc
    反時計回り
  x y r angle1 angle2 arcn
    時計回り

  x1 y1 x2 y2 r arct
  x1 y1 x2 y2 r arct xt1 yt1 xt2 yt2

    角 (p0 p1 p2) に内接する弧を描く。
    辺 (p0 p1) との接点を t1 とし、辺 (p1 p2) との接点を t2 とする。
    
  arcto

計画2. 属性の再実装
~~~~~~~~~~~~~~~~~~~
  TODO:
    __raccess__ を使ってアクセスを制限する事
    知らずに !__waccess__  なのに書き込んでいる場所をチェックする事
    使用している箇所は、grep '\.offset' すれば分かる。
    特に文字列に関しては何もチェックを行って来なかった。

計画3. 最適化
~~~~~~~~~~~~~
・繰り返し実行する ExecutableArray は JavaScript 関数に変換
  PsArray の内容に変更があった場合には、作成した JavaScript 関数を破棄する。
  ■this.data.ver の更新
  ■for 以外の制御構文も __function__ に対応
  →頻繁に使用されるオペレータを inline 化できる様にする。
    これについては実装した。
    然し、どれが頻繁に利用されるオペレータか? というのは良く分からないので、
    Profile を取りながら逐次追加していく事にする。
  
・__function__ に依存名辞書を附属させるの事
  それと共に def や put/begin 等を実行した際に「変更点」を記録しておく
  
  そうしておけば、例え bind をしていても __function__ を実行する前に、
  それらの「変更点」に自分自身が影響を受けるかどうか判定して、
  必要な時にちゃんと自身を更新する事が出来る様になる。
  
  (唯、systemdict begin 等を毎回して内側で関数を実行する様な場合には、
  必ず再構築をしなければならなくなり、逆に滅茶苦茶遅くなってしまう。
  内側でなくても、関数の実行と実行の間に一度でも
  systemdict begin を使用するコードがあると同じ事である。)
  
  →begin も end も使わないし、また、def も put も使わない状況。
  その様な状況でしかこの方法は有効でない。
  然し、その様な状況は少なく、逆に、
  多くの状況では何度もコンパイルする事になり滅茶苦茶遅くなってしまう。
  この方法は現実的ではない。
  
  それよりは、寧ろ、以降に続くコマンドを走査して begin や put 等がある場合には
  初めから deep bind でコンパイルを実行しない様にする方が増しである。
  (とは言っても、実際には以降に来得るコマンドをちゃんと予測する事は不可能である。
  文字列操作をしてそう言うコマンドを自動的に生成しそれを実行する場合や、
  外部ファイルを読み込んでそれを実行する場合など色々ある。)
  
・Optimizer クラスの下で、JavaScript 化コードを再検討する。
・Scanner 部分を実装し直す→具体的には [計画4] 参照

計画4. PsFile の実装
~~~~~~~~~~~~~~~~~~~~
  ファイル入出力の部分を統一的に実装し直す。
  
  ファイルは以下のメンバを持つ
  {
    next_char:function(){},
    filename:'run<hoge>' // 'eexec<hoge>', 'string<hoge>'
    iline:0,
    icol:0,
  }
  
  ・Scanner は上を override する形で定義する。
  ・特に、string を元とするファイルに関しては、
    正規表現を用いるなどの方法を用いて高速化したバージョンも用意する。
    
計画5. エラー処理
~~~~~~~~~~~~~~~~~
  真面目に実装する…?
  ・スタックの状態を復元する。
  ・スタックアンダーフローの検出
