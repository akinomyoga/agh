// -*- mode: js -*-

agh.memcpy(ns.Modules["core"].ErrorMessages, {
  'mod:array.env:array.ctx:align.UnknownAlignmentCharacter': [
    "unknown align char '{ch}'",
    "指定した文字 '{ch}' は、表組みの alignment 指定子として未知です。\n"
      +"lcr 又は @, p, * 等を組み合わせて指定して下さい。"],
  'mod:array.cmd:multicolumn.DoubleAlignmentCharacter': [
    "extra align spec",
    "'{ch}' は二回目の alignment の設定です。\n"
      +"\\multicolumn に対して複数の alignment を設定する事は出来ません。"],
  'mod:array.cmd:multicol.EmptyAlignment': [
    "missing alignment", "\\multicolumn の第二引数に alignment の指定が含まれていません。\nlcr の何れかを指定して下さい。"],
  'mod:array.cmd:multicol.MulticolAlreadyHasContent': [
    "invalid \\{cmdName}", "Cells with contents cannot be turned into muticolumn cells."],
  'mod:array.cmd:multicol.MulticolAlreadyMulticol': [
    "invalid \\{cmdName}", "The multicolumn commands cannot be specified more than once in a single cell."],
  'mod:array.env:array.ctx:align.ltr:p.MissingArgument': [
    "missing arg", "alignment 指定子 p には引数が必要です。\np{width} の形式で引数を指定して下さい。"],
  'mod:array.env:array.ctx:align.ltr:*.InvalidRepeatNumber': [
    "invalid arg for '*'", "* の第一引数には繰り返し回数を示す正の整数値を指定して下さい。"],
  'mod:array.env:array.ctx:align.ltr:*.EmptyContent': [
    "missing arg", "* に第二引数がありません。\n第二引数には、繰り返す内容を指定して下さい。"],
  "mod:array.env:array.ExtraContentAfterMulticol": [
    "extra cell content",
    "\\multicol を指定した直後にセル内容を記述する事は出来ません。\n"
      + "\\ 又は & を用いて次の列か次の行に移ってから内容を既述して下さい。"],
  'mod:array.env:array.cmd:cline.InvalidRange': [
    "'{cmdName}' invalid arg",
    "第一引数 '{range}' は無効な形式です。\n"
      + "\\cline コマンドの第一引数は /\\d+\\-\\d+/ の形で指定して下さい。"],
  'mod:array.env:array.InvalidVerticalAlign': [
    "invalid valign",
    "指定した値 '{valign}' は垂直位置指定として不適切です。\r\ntbm のいずれかの値を指定して下さい。"],
  'mod:array.env:array.ExtraColumn': [
    "extra column", "指定された列数よりも多くの列が指定されています。\nalignment を正しく指定して下さい。"],
  'mod:array.env:eqnarray.ExtraColumn': [
    "extra column", "既定の列数よりも多くの列が指定されています。\neqnarray 環境では三列までしか使用する事は出来ません。"],
  'mod:array.env:gather.ExtraColumn': [
    "extra column", "gather 環境では複数の列を指定する事はできません。\\begin{align} 環境の使用を検討して下さい。"],
  'mod:array.env:eqnarray.ContextBroken': [
    "BUG/env:eqnarray", "ctx:env.eqnarray/cmd:\\\\: array context is not set. this command should be used inside env:eqnarray."],
  'mod:array.env:array.InvalidNextLine': [
    "invalid '{cmdName}'",
    "environment array: この場所で次の行に移る事は出来ません。"],
  'mod:array.env:array.InvalidNextColumn': [
    "invalid '{cmdName}'",
    "environment array: この場所で次の列に移る事は出来ません。"],
  'mod:array.env:array.InvalidHorizontalLine': [
    "invalid '{cmdName}'",
    "environment array: この場所で横罫線を設定する事は出来ません。"],
  'mod:array.env:array.InvalidMulticolumn': [
    "invalid '{cmdName}'",
    "environment array: この場所で複数列セルを宣言する事は出来ません。"],
  'mod:array.env:array.InvalidHdotsfor': [
    "invalid '{cmdName}'",
    "environment array: この場所で水平点線を宣言する事は出来ません。"],
  'mod:array.env:alignat.NegativeColumnNumber': [
    "invalid column number",
    "environment alignat: '{arg1}' は不正な列数です。列数には正の整数を指定して下さい。"]
});

var mod_core = ns.Modules["core"];
var mod_base = ns.Modules["mod:base"];
var _Mod = ns.Modules["mod:array"] = {};

agh.Namespace("ArrayTable", ns);
var _at = ns.ArrayTable;
_at.toAlign = (function() {
  var aligns = {
    "r": ' align="right"',
    "c": ' align="center"',
    "l": ' align="left"',
    "-": ''
  };
  return function(ltr) {
    if (ltr in aligns) return aligns[ltr];
    return "";
  };
})();
_at.toAlignClassName = function(ltr) {
  if (ltr == "r") return ' aghtex-array-cell--right';
  if (ltr == "c") return ' aghtex-array-cell--center';
  if (ltr == "l") return ' aghtex-array-cell--left';
  return "";
};
//********************************************************************
//
//    class Cell
//
//********************************************************************
_at.Cell = function(parent, x, y) {
  this.table = parent;
  this.x = x;
  this.y = y;
};
agh.memcpy(_at.Cell.prototype, {
  //****************************************************************
  //    既定値
  //****************************************************************
  content: "",     // セル内容
  is_hdots: false, // 水平に点線を表示するかどうか
  borderL: null, // Array of 1 or "@ string"
  borderR: null, // Array of 1 or "@ string"
  borderT: null,
  colspan: 1,
  is_spanpad: false,
  width: null,
  paddingL: null,
  paddingR: null,
  align: null,
  //----------------------------------------------------------------
  get_col: function() {
    return this.table.col(this.y);
  },
  get_bL: function() {
    return this.borderL || this.y == 0 && this.table.col(0).borderL;
  },
  get_bR: function() {
    return this.borderR || this.table.col(this.y).borderR;
  },
  get_bT: function() {
    if (this.x != 0) return false;
    if (this.borderT != null) return this.borderT;
    return !!this.table.borderH[0];
  },
  get_bB: function() {
    if (this.borderB != null) return this.borderB;
    return !!this.table.borderH[this.x + 1];
  },
  get_width: function() {
    if (this.width != null) return this.width;
    return this.table.col(this.y).width;
  },
  get_pL: function() {
    if (this.paddingL != null) return this.paddingL;
    return this.get_col().paddingL;
  },
  get_pR: function() {
    if (this.paddingR != null) return this.paddingR;
    return this.get_col().paddingR;
  },
  get_pB: function() {
    var line = this.table.line(this.x);
    if (line) return line.paddingBottom;
    return null;
  },
  get_align: function() {
    if (this.align != null) return this.align;
    return this.get_col().halign;
  },
  //****************************************************************
  //    幾何
  //****************************************************************
  /// <summary>
  /// この cell を表示するのに要する列数を返します。
  /// </summary>
  //cols: function() {
  //  return 1 + this.cols_bL() + this.cols_bR();
  //},
  cols_bL: function(bL) {
    // 左 border の取得
    bL = bL || this.get_bL();
    if (!bL) return 0;

    var r = 0;
    var right = true;
    agh.Array.eachR(bL, function(b) {
      if (!right | (right = b != 1)) r++; // (右が線) or (今回升) ⇒ ret++
    });

    return r;
  },
  cols_bR: function(bR) {
    bR = bR || this.get_bR();
    if (!bR) return 0;

    var r = 0;
    var left = true; // 左が升 (新しい td) か否か
    agh.Array.each(bR, function(b) {
      if (!left | (left = b != 1)) r++; // (左が線) or (今回升) ⇒ ret++
    });
    return r;
  },
  //****************************************************************
  //    出力
  //****************************************************************
  write: function(output) {
    if (this.is_spanpad) return;

    // 総 td@colspan 計算 (multicolumn も考慮)
    var x = this.x;
    var y = this.y;
    var totspan = 0;
    for (var i = 0; i < this.colspan; i++)
      totspan += this.table.col(y + i).tdc;

    // 書き出し (multicolumn の場合は最後の cell が担当)
    var wcell = this.table.cell(x, y + this.colspan - 1);
    wcell.write_internal(
      output,
      this.get_bL(),
      wcell.get_bR(),
      totspan);
  },
  write_internal: function(output, bL, bR, tdspan) {
    bL = bL || [];
    bR = bR || [];
    var sty = new ns.Writer();
    var sbuff = sty.buff;

    // calc main-td colspan
    tdspan -= this.cols_bR(bR) + this.cols_bL(bL);

    // border の描画方法
    //   [左 border], [内容], [右 border] の順に内容を出力する。
    //   できるだけ少ない列数で出力を行う為に、
    //   "中心TD" ([内容] を表示する為の TD) の左右の border も利用する。
    //   つまり、[左 border] の最後の縦線、[右 border] の最初の縦線は "中心TD" を用いて表示する。
    //
    // bbL bbR bbT bbB: "中心TD" の上下左右に border を表示するかどうか
    var bbL = agh.Array.last(bL) === 1;
    var bbR = agh.Array.first(bR) === 1;
    var bbT = this.get_bT();
    var bbB = this.get_bB();
    if (bbL || bbR || bbT || bbB) {
      sbuff.push('border-width:', bbT ? 1 : 0, 'px ', bbR ? 1 : 0, 'px ', bbB ? 1 : 0, 'px ', bbL ? 1 : 0, 'px!important;');
      if (bbL) bL = bL.slice(0, -1);
      if (bbR) bR = bR.slice(1);
    }

    var pL = this.get_pL();
    if (pL != null) sbuff.push('padding-left:', pL, '!important;');
    var pR = this.get_pR();
    if (pR != null) sbuff.push('padding-right:', pR, '!important;');
    var pB = this.get_pB();
    if (pB != null) sbuff.push('padding-bottom:', pB, '!important;');
    var width = this.get_width();
    if (width != null) sbuff.push('width:', width, '!important;');

    this.write_bL(output, bL, bbT, bbB);

    // 本体書き出し
    var className = 'aghtex-array-cell';
    var content = this.content;
    if (this.is_hdots) {
      var hdots_type = 'hdots';
      if (agh.browser.vIE < 10) hdots_type = 'hdots-ie9';
      content = '<tex:i class="aghtex-array-' + hdots_type + '"></tex:i>' + content;
      className += ' aghtex-array-cell--hdots';
    }
    className += _at.toAlignClassName(this.get_align());

    var buff = output.buff;
    buff.push(' <td class="aghtex-css-td ', className, '"');
    buff.push(_at.toAlign(this.get_align()));
    if (tdspan > 1) buff.push(' colspan="', tdspan, '"');
    var style = sty.toHtml();
    if (style.length > 0) {
      buff.push(' style="', style, '"');
      // ■ padding
    }
    buff.push('>', content, '</td>\n');

    this.write_bR(output, bR, bbT, bbB);
  },
  write_bL: function(output, bL, bT, bB) {
    var bw_left   = 0;
    var bw_top    = bT ? 1 : 0;
    var bw_bottom = bB ? 1 : 0;
    var bw_right  = 0;

    var buff = output.buff;
    for (var i = 0, iN = bL.length; i < iN; i++) {
      var border = bL[i];
      if (typeof border == "string" || border instanceof String) {
        buff.push(
          ' <td class="aghtex-css-td aghtex-array-border-txt" style="border-width:',
          bw_top, 'px ', bw_right, 'px ', bw_bottom, 'px ', bw_left, 'px!important;">',
          border, '</td>\n');

        bw_left = 0;
      } else if (border === 1) {
        if (bw_left > 0) {
          buff.push(
            ' <td class="aghtex-css-td aghtex-array-border-zw" style="border-width:',
            bw_top, 'px ', bw_right, 'px ', bw_bottom, 'px ', bw_left, 'px!important;"></td>\n');
        }

        bw_left = 1;
      } else {
//#debug
        alert("Fatal @ array2.ctx/write_bL\n予期しない境界線指定子です。");
        throw new Error("unexpected border-spec");
//#end debug
      }
    }

    if (bw_left > 0) {
      buff.push(
        ' <td class="aghtex-css-td aghtex-array-border-zw" style="border-width:',
        bw_top, 'px ', bw_right, 'px ', bw_bottom, 'px ', bw_left, 'px!important;"></td>\n');
    }
  },
  write_bR: function(output, bR, bT, bB) {
    var bw_left    = 0;
    var bw_top     = bT ? 1 : 0;
    var bw_bottom  = bB ? 1 : 0;
    var bw_right   = 0;
    var td_content = null;

    function emit_cell() {
      if (td_content != null) {
        buff.push(
          ' <td class="aghtex-css-td aghtex-array-border-txt" style="border-width:',
          bw_top, 'px ', bw_right, 'px ', bw_bottom, 'px ', bw_left, 'px!important;">',
          td_content, '</td>\n');

        bw_right = 0;
        td_content = null;
      } else {
        buff.push(
          ' <td class="aghtex-css-td aghtex-array-border-zw" style="border-width:',
          bw_top, 'px ', bw_right, 'px ', bw_bottom, 'px ', bw_left, 'px!important;"></td>\n');

        bw_right = 0;
      }
    }

    var buff = output.buff;
    for (var i = 0, iN = bR.length; i < iN; i++) {
      var border = bR[i];
      if (typeof border == "string" || border instanceof String) {
        if (td_content != null)
          emit_cell();

        td_content = border;
      } else if (border === 1) {
        bw_right = 1;
        emit_cell();
        // assert(bw_right == 0);
      } else {
//#debug
        alert("Fatal @ array2.ctx/write_bL\n予期しない境界線指定子です。");
        throw new Error("unexpected border-spec");
//#end debug
      }
    }

    if (td_content != null)
      emit_cell();
  },
  "0": 0
});
//********************************************************************
//
//    class Column
//
//********************************************************************
_at.Column = function(parent, y, copye) {
  this.table = parent;
  this.y = y;

  // この列を表示するのに使用する td の数を保持します。
  // 表示の直前 (Table#write) に update_tdc によって更新されます。
  this.tdc = 1;
  this.tdcL = 0;
  this.tdcR = 0;

  if (copye instanceof _at.Column) {
    this.width = copye.width;
    this.halign = copye.halign;
    this.borderL = copye.borderL;
    this.borderR = copye.borderR;
    this.paddingL = copye.paddingL;
    this.paddingR = copye.paddingR;
  }
};
agh.memcpy(_at.Column.prototype, {
  //****************************************************************
  //    既定値
  //****************************************************************
  borderL: null,
  borderR: null,
  halign: null,
  width: null,
  paddingL: null,
  paddingR: null,
  //****************************************************************
  //    設定
  //****************************************************************
  add_bL: function(b) {
    (this.borderL || (this.borderL = [])).push(b);
  },
  add_bR: function(b) {
    (this.borderR || (this.borderR = [])).push(b);
  },
  //****************************************************************
  //    出力
  //****************************************************************
  /// <summary>
  /// この列を表示するのに必要な td の数を計算します。
  /// </summary>
  update_tdc: function() {
    var table = this.table;
    var maxL = 0;
    var maxR = 0;
    for (var x = 0; x < table.xM; x++) {
      var c = table.cell(x, this.y);
      var l = c.cols_bL();
      if (l > maxL) maxL = l;
      var r = c.cols_bR();
      if (r > maxR) maxR = r;
    }
    this.tdc = maxL + 1 + maxR;
    this.tdcL = maxL;
    this.tdcR = maxR;

    return this.tdc;
  },
  _isPaddingLeftText: function() {
    var b = null;
    if (this.borderL != null) {
      b = agh.Array.last(this.borderL);
    } else if (this.y > 0) {
      var prev = this.table.col(this.y - 1).borderR;
      if (prev != null) b = agh.Array.last(prev);
    }
    return (typeof b == "string" || b instanceof String);
  },
  _isPaddingRightText: function() {
    var b = null;
    if (this.borderR != null)
      b = agh.Array.first(this.borderR);
    return (typeof b == "string" || b instanceof String);
  },
  update_padding: function() {
    var table = this.table;

    // paddingL
    if (this._isPaddingLeftText())
      this.paddingL = "0px";
    else if (this.y == 0)
      this.paddingL = "0.3ex"; // 最左列既定値

    // paddingR
    if (this._isPaddingRightText())
      this.paddingR = "0px";
    else if (this.y == this.table.yM - 1)
      this.paddingR = "0.3ex"; // 最右列既定値
  }
});
_at.CreateDummyColumn = function() {
  var table = new _at.Table();
  var y = 0;
  return new _at.Column(table, y);
};
//********************************************************************
//
//    ctx Align
//
//********************************************************************
//    AlignSetter
//====================================================================
_at.AlignSetterKey = new Object();
_at.TableAlignSetter = function(table) {
  this.table = table;
};
agh.memcpy(_at.TableAlignSetter.prototype, {
  setAlign: function(ltr) {
    var t = this.table;
    if (t.col().halign) t.next_col();
    t.col().halign = ltr;
  },
  setWidth: function(w) {
    this.table.col().width = w;
  },
  setBorder: function(b) {
    var t = this.table;
    if (t.cy == 0 && !t.col().halign) {
      t.col().add_bL(b); // 一番左の境界線
    } else {
      t.col().add_bR(b);
    }
  },
  idKey: _at.AlignSetterKey
});
_at.MulticolAlignSetter = function(doc, lcell, rcell) {
  this.doc = doc;
  this.lcell = lcell;
  this.rcell = rcell;
  this.align_set = false;
};
agh.memcpy(_at.MulticolAlignSetter.prototype, {
  setAlign: function(ltr) {
    if (this.align_set) {
      this.doc.currentCtx.output.error(
        'mod:array.cmd:multicolumn.DoubleAlignmentCharacter', {ch: ltr},
        "\\multicolumn.argument#1");
      return;
    }
    this.rcell.align = ltr;
    this.align_set = true;
  },
  setWidth: function(w) {
    this.rcell.width = w;
  },
  setBorder: function(b) {
    if (!this.align_set) {
      this.lcell.borderL.push(b);
    } else {
      this.rcell.borderR.push(b);
    }
  },
  idKey: _at.AlignSetterKey
});
//====================================================================
//    AlignHandlers
//====================================================================
// text_modifier として動作するハンドラ達
_at.AlignHandlers = {
  getAlignSetter: function(doc, ltr) {
    var setter = doc.currentCtx.CTXDATA;
//#debug
    if (setter.idKey !== _at.AlignSetterKey) {
      alert([
        "LOGIC_ERROR",
        "場所: array2.ctx/context env.array.align/command '" + ltr + "'",
        "状況: align 指定コマンドが呼び出されましたが、",
        "　　　ここは env.array.align context 直下ではありません。",
        "・env.array.align の text_modifier が子孫 context に混入している可能性",
        "・env.array.align で定義されたコマンドが子孫 context に混入している可能性"
      ].join("\n"));
      throw new Error("internal error");
    }
//#end debug
    return setter;
  },
  processText: function(doc, text) {
    // 最後の文字以外
    var iLast = text.length - 1;
    for (var i = 0; i < iLast; i++) {
      var c = text.substr(i, 1);
      if (!(c in this)) c = 0; // 既定のハンドラ
      this[c](doc, c);
    }

    // 最後の文字は文字ハンドラとして動作
    var c = text.substr(iLast, 1);
    var lh = doc.currentCtx.GetLetterHandler(c);
    if (lh == null) {
      doc.scanner.Next();
      this[0](doc, c);
      return;
    }
    lh(doc, c);
  },
  //-- handlers
  c: function(doc, ltr) {
    var setter = _at.AlignHandlers.getAlignSetter(doc, ltr);
    if (setter != null) setter.setAlign(ltr);
  },
  p: function(doc, ltr) {
    // エラー (之が呼び出される＝text の最後の文字ではない＝引数がない)
    doc.currentCtx.output.error(
      'mod:array.env:array.ctx:align.ltr:p.MissingArgument', null,
      "ltr:p (ctx:env.array.align)");
  },
  "0": function(doc, ltr) {
    doc.currentCtx.output.error(
      'mod:array.env:array.ctx:align.UnknownAlignmentCharacter', {ch: ltr},
      "letter '" + ltr + "' (ctx:env.array.align)");
  }
};
agh.memcpy(_at.AlignHandlers, _at.AlignHandlers, {l: "c", r: "c"});
context "env.array.align" new("sub.braced") {
  _Ctx.key = "env.array.align";
  _Ctx.initializer = function(mainctx) {
    if (mainctx[_Ctx.key]) return;
    mainctx[_Ctx.key] = true;

    // 直接
    if (!mainctx.ContainsBaseContext(this)) return;

    // (既に text_modifier が登録されていても無視)
    mainctx.text_modifier = function(doc, text) {
      if (text.length == 0) {
        doc.scanner.Next();
        return text;
      }

      _at.AlignHandlers.processText(doc, text);

      return "";
    };
  };
  //================================================================
  //>#1 を読み取るのに使用する context は…? 出来るだけ親 ctx が良い
  //→親に対応する context 名 .. を定義した。
  _Ctx.DefineLetter({
    "lcr": function(doc, cmdName) {
      doc.scanner.Next();
      _at.AlignHandlers[cmdName](doc, cmdName);
    },
    '|': function(doc, cmdName) {
      doc.scanner.Next();
      var setter = _at.AlignHandlers.getAlignSetter(doc, '|');
      if (setter != null) setter.setBorder(1);
    },
    'p': ['f;#D', function(doc, argv) {
      var setter = _at.AlignHandlers.getAlignSetter(doc, 'p');
      if (setter != null) {
        setter.setAlign('l');
        setter.setWidth(argv[1].toString());
      }
    }],
    '@': ['f;#..>1', function(doc, argv) {
      var setter = _at.AlignHandlers.getAlignSetter(doc, '@');
      if (setter != null) setter.setBorder(argv[1]);
    }],
    '*': ['f;#..!1#@2', function(doc, argv) {
      var output = doc.currentCtx.output;
      var i = parseInt(argv[1]);
      if (isNaN(i) || i < 1) {
        output.error(
          'mod:array.env:array.ctx:align.ltr:*.InvalidRepeatNumber', null,
          "ltr:* (ctx:env.array.align)");
        i = 1;
      }

      if (argv[2] == null) {
        output.error(
          'mod:array.env:array.ctx:align.ltr:*.EmptyContent', null,
          "ltr:* (ctx:env.array.align)");
        return;
      }

      // 挿入
      doc.scanner.InsertSource(argv[2].toString().repeat(i));
    }],
    "!\"#$'()=~-^`{[;:]+,./&<>?_&<>": function(doc, cmdName) {
      doc.scanner.Next();
      _at.AlignHandlers[0](doc, cmdName);
    },
    "\0\b\t\n\v\f\r 　": mod_base["cmd:relax"],
    "\x01\x02\x03\x04\x05\x06\x07\x0e\x0f": mod_base["cmd:relax"],
    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f": mod_base["cmd:relax"]
  });
}
//********************************************************************
//
//    class Table
//
//********************************************************************
_at.Table = function() {
  this.cells = [];
  this.borderH = [];  // 水平線データ

  this.cols = [];  // 列情報 [new Column, ...]

  // 行情報 [{paddingBottom, }, ...]
  //   paddingBottom は \\[1cm] で指定される vskip により設定される。
  //   行に属する各セルに paddingBottom を出力する。
  this.lines = [];
};
agh.memcpy(_at.Table.prototype, {
  //****************************************************************
  //    既定値
  //****************************************************************
  xM: 0,    // 行列の横の大きさ
  yM: 0,    // 行列の縦の大きさ
  cx: 0,
  cy: 0,
  valign: "m",

  m_defaultCol: null,
  m_subsup: null,
  //****************************************************************
  //    データ
  //****************************************************************
  cell: function(x, y) {
    if (x == null) x = this.cx;
    if (y == null) y = this.cy;
    while (x >= this.xM)
      this.cells[this.xM++] = [];
    if (y >= this.yM) this.yM = y+1;

    return this.cells[x][y] || (this.cells[x][y] = new _at.Cell(this, x, y));
  },
  line: function(x) {
    if (x == null) x = this.cx;
    var line = this.lines[x];
    if (line)
      return line;
    else
      return this.lines[x] = {};
  },
  col: function(y) {
    if (y == null) y = this.cy;
    if (y >= this.yM) this.yM = y+1;

    var column = this.cols[y];
    if (column)
      return column;
    else if (this.m_defaultCol)
      return this.cols[y] = new _at.Column(this, y, this.m_defaultCol);
    else
      return this.cols[y] = this.col_hookCreateNew(y);
  },
  col_hookCreateNew: function(y) {
    /// <summary>
    /// 列オブジェクトを初期化します。
    /// 新しく作成される列に変更を加えたい場合はこの関数を置き換えて下さい。
    /// </summary>
    return new _at.Column(this, y);
  },
  default_col: function() {
    if (!this.m_defaultCol)
      this.m_defaultCol = _at.CreateDummyColumn();
    return this.m_defaultCol;
  },
  //****************************************************************
  //    align 設定
  //****************************************************************
  // next_col() で移動
  //----------------------------------------------------------------
  clear_pos: function() {
    this.cy = 0;
    this.cx = 0;
  },
  //****************************************************************
  //    設定
  //****************************************************************
  // 水平線
  getHorizontalLines: function(row) {
    return this.borderH[row] || 0;
  },
  addHorizontalLines: function(row, count) {
    if (this.borderH[row] == null)
      this.borderH[row] = 0;

    this.borderH[row] += count || 1;
  },
  getHtmlRowCount: function() {
    var r = this.xM;
    for (var x = 0; x <= this.xM; x++) {
      var h = this.getHorizontalLines(x) - 1;
      if (h > 0) r += h;
    }
    return r;
  },
  //----------------------------------------------------------------
  next_col: function() {
    this.cy++;
  },
  next_row: function() {
    this.cx++;
    this.cy = 0;
  },
  set_hline: function() {
    this.addHorizontalLines(this.cx, 1);
  },
  _multispan_checkExistingCellContents: function(doc, commandName) {
    if (this.cell().is_multicol) {
      doc.currentCtx.output.error(
        'mod:array.cmd:multicol.MulticolAlreadyMulticol', {cmdName: commandName},
        "\\" + commandName + " (ctx:array)");
      return false;
    }

    var cellContent = doc.currentCtx.output.toHtml().trim();
    if (cellContent !== "") {
      doc.currentCtx.output.error(
        'mod:array.cmd:multicol.MulticolAlreadyHasContent', {cmdName: commandName},
        "\\" + commandName + " (ctx:array)");
    }

    return true;
  },
  _multispan_connectHorizontalCells: function(span) {
    this.cell().colspan = span;
    this.cell().is_multicol = true;
    for (var i = 1; i < span; i++) {
      var c = this.cell(this.cx, this.cy + i);
      c.is_spanpad = true;
      c.is_multicol = true;
    }
  },
  set_multicol: function(doc, span, align, content) {
    if (!this._multispan_checkExistingCellContents(doc, "multicolumn")) {
      doc.currentCtx.output.buff.push(content);
      return;
    }
    this._multispan_connectHorizontalCells(span);

    // 内容の設定
    var lcell = this.cell();
    this.cy += span - 1;
    var rcell = this.cell();
    rcell.content = content;

    // align の解釈
    lcell.borderL = [];
    rcell.borderR = [];

    var ctx_aln = doc.context_cast(["sub.braced", "env.array.align"]);
    ctx_aln.CTXDATA = new _at.MulticolAlignSetter(doc, lcell, rcell);
    doc.scanner.InsertSource("{" + align + "}");
    doc.scanner.Next(); // "{" の次
    var r = doc.Read(ctx_aln);
    if (r) doc.currentCtx.output.buff.push(r);

    if (rcell.align == null) {
      doc.currentCtx.output.error(
        'mod:array.cmd:multicol.EmptyAlignment', null,
        "\\multicolumn (ctx:array)");
    }
  },
  set_hdots: function(doc, span) {
    if (!this._multispan_checkExistingCellContents(doc, "hdotsfor")) return;
    this._multispan_connectHorizontalCells(span);
    var lcell = this.cell();
    this.cy += span - 1;
    var rcell = this.cell();

    lcell.borderL = [];
    rcell.borderR = [];
    rcell.is_hdots = true;
  },
  set_cline: function(start, end) {
    start--;
    if (start < 0) start = 0;
    if (this.cx == 0) for (var i = start; i < end; i++) {
      this.cell(0, i).borderT = true;
    } else for (var i = start; i < end; i++) {
      this.cell(this.cx - 1, i).borderB = true;
    }
  },
  get_current_col: function() {
    return this.cy;
  },
  setSubSup: function(value) {
    this.m_subsup = value;
  },
  //****************************************************************
  //    出力
  //****************************************************************
  write: function(output) {
    if (this.param_bracket || this.m_subsup) {
      var ltr1 = this.param_bracket && this.param_bracket[0];
      var ltr2 = this.param_bracket && this.param_bracket[1];
      var self = this;
      var content_writer = function(output) { self.write_content(output); };
      mod_base.OutputBracketedContent(output, content_writer, ltr1, ltr2, null, this.m_subsup);
    } else {
      this.write_content(output);
    }
  },
  write_content: function(output) {
    // init this.cols
    // 　各 cell 列に使用する td 列数の計算
    var tdc_total = 0;
    for (var y = 0; y < this.yM; y++) {
      this.col(y).update_padding();
      tdc_total += this.col(y).update_tdc();
    }

    // header
    var buff = output.buff;
    buff.push('<table class="aghtex-css-table-inline aghtex-array-table aghtex-array-valign-', this.valign, '"><tbody>\n');

    // thead (colgroups or dummy-row)
    this.write_thead(output);

    // content
    this.write_bT(output, tdc_total);
    for (var x = 0; x < this.xM; x++) {
      if (x == 0)
        buff.push('<tr class="aghtex-css-tr aghtex-array-first-row">\n');
      else if (x == this.xM - 1)
        buff.push('<tr class="aghtex-css-tr aghtex-array-last-row">\n');
      else
        buff.push('<tr class="aghtex-css-tr">\n');

      for (var y = 0; y < this.yM; y++) {
        if (this.cells[x][y])
          this.cells[x][y].write(output);
      }
      buff.push('</tr>\n');

      this.write_bB(output, tdc_total, x);
    }
    buff.push('</tbody></table>');
  },
  write_thead: function(output) {
    var buff = output.buff;

    if (agh.browser.vFx) {
      buff.push('<tr class="aghtex-css-tr aghtex-array-fxdummy-row">\n');
      for (var y = 0; y < this.yM; y++) {
        var col = this.col(y);
        buff.push(' ');
        for (var i = 0; i < col.tdcL; i++) buff.push('<td class="aghtex-css-td aghtex-array-fxdummy-border" />');
        buff.push('<td class="aghtex-css-td aghtex-array-fxdummy-cell" style="width:auto!important;"><tex:i class="aghtex-array-fxdummy-content">.</tex:i></td>');
        for (var i = 0; i < col.tdcR; i++) buff.push('<td class="aghtex-css-td aghtex-array-fxdummy-border" />');
        buff.push('\n');
      }
      buff.push('</tr>\n');
    }
  },
  write_bT: function(output, tdc_total) {
    // Note: IE とそれから Chrome で時々、中に dummy 要素がないと高さが潰れる。
    var h = this.getHorizontalLines(0) - 1;
    while (h-- > 0) {
      output.buff.push(
        '<tr class="aghtex-css-tr"><td class="aghtex-css-td aghtex-array-hline-t" colspan="', tdc_total,
        '"><tex:i class="aghtex-array-hline-dummy">&nbsp;</tex:i></td></tr>\n');
    }
  },
  write_bB: function(output, tdc_total, x) {
    var h = this.getHorizontalLines(x + 1) - 1;
    while (h-- > 0) {
      output.buff.push(
        '<tr class="aghtex-css-tr"><td class="aghtex-css-td aghtex-array-hline-b" colspan="', tdc_total,
        '"><tex:i class="aghtex-array-hline-dummy">&nbsp;</tex:i></td></tr>\n');
    }
  },
  "0": 0
});
//********************************************************************
//
//    func Handlers
//
//********************************************************************
agh.memcpy(_at.Table, {
  GetTable: function(doc, cmdName, msg_action) {
    var data = doc.currentCtx.ENVDATA;
    if (!(data instanceof _at.Table)) {
      doc.currentCtx.output.error(
        'mod:array.env:array.Invalid' + msg_action, {cmdName: cmdName},
        "\\" + cmdName);
      return null;
    }
    return data;
  },
  // &
  H_NEXT_COL: function(doc, cmdName) {
    doc.scanner.Next();
    var data = _at.Table.GetTable(doc, cmdName, "NextColumn");
    if (data == null) return;

    var output = doc.currentCtx.output;
    clearArrayContext(doc.currentCtx);
    if (data.cell().is_multicol) {
      var cont = output.toHtml().trim();
      if (cont) {
        output.error(
          'mod:array.env:array.ExtraContentAfterMulticol', null,
          "ltr:& (env:array)");
        data.cell().content += cont;
      }
      output.clear();
      data.next_col();
      return;
    }

    data.cell().content = output.toHtml();
    output.clear();
    data.next_col();
  },
  // \\[dimen]
  H_NEXT_ROW: new ns.Command2("f", "#[]D", function(doc, argv) {
    var data = _at.Table.GetTable(doc, argv[0], "NextLine");
    if (data == null) return;

    var output = doc.currentCtx.output;
    clearArrayContext(doc.currentCtx);
    if (argv[1]) data.line().paddingBottom = argv[1];
    data.cell().content += output.toHtml();
    output.clear();

    data.next_row();
  }),
  H_HLINE: function(doc, cmdName) {
    doc.scanner.Next();
    var data = _at.Table.GetTable(doc, cmdName, "HorizontalLine");
    if (data == null) return;

    data.set_hline();
  },
  // \cline{1-3}
  H_CLINE: new ns.Command2("f", "#mode.para!1", function(doc, args) {
    var data = _at.Table.GetTable(doc, args[0], "HorizontalLine");
    if (data == null) return;
    var output = doc.currentCtx.output;

    // chk 引数
    var s = args[1].match(/^\s*(\d)+\s*\-\s*(\d+)/);
    if (s == null) {
      output.error(
        'mod:array.env:array.cmd:cline.InvalidRange', {cmdName: args[0], range: args[1]},
        "\\" + args[0]);
      return;
    }

    data.set_cline(parseInt(s[1]), parseInt(s[2]));
  }),
  // \multicolumn{2}{|c|}{content}
  H_MULTICOL: new ns.Command2("f", "#!1#@2#>3", function(doc, args) {
    var data = _at.Table.GetTable(doc, args[0], "Multicolumn");
    if (data == null) return;

    var cnum = parseInt(args[1]);
    if (isNaN(cnum) || cnum <= 0) cnum = 1;
    var csty = args[2];
    var content = args[3];

    // ■ 既に内容があった場合警告
    data.set_multicol(doc, cnum, csty, content);
  }),
  H_HDOTSFOR: new ns.Command2("f", "#!1", function(doc, args) {
    var data = _at.Table.GetTable(doc, args[0], "Hdotsfor");
    if (data == null) return;

    var cnum = parseInt(args[1]);
    if (isNaN(cnum) || cnum <= 0) cnum = 1;
    data.set_hdots(doc, cnum);
  })
});
// export for use in amsmath
_Mod["cmd:hdotsfor"] = _at.Table.H_HDOTSFOR;
//*****************************************************************************
//  array 環境
//-----------------------------------------------------------------------------
var CTXV_LABEL_EQ = 'mod_ref/label:eq';
var CTXV_ARRAYCTX = 'mod_array/arrayCtx';
var CTXV_NOTAG = 'mod_array/notag';
var CTXV_EQTAG = 'mod_array/eqtag';
var CTXV_RAISETAG = 'mod_array/raisetag';

function setupArrayContext(ctx) {
  ctx.dataV[CTXV_ARRAYCTX] = ctx;
  ctx.dataV[CTXV_NOTAG] = false;
  ctx.dataV[CTXV_EQTAG] = false;
  ctx.dataV[CTXV_RAISETAG] = false;
  ctx.dataV[CTXV_LABEL_EQ] = [];
}
function clearArrayContext(ctx) {
  ctx.dataV = agh.memcpy({}, ctx.dataV, [
    CTXV_ARRAYCTX, CTXV_NOTAG, CTXV_EQTAG,
    CTXV_RAISETAG, CTXV_LABEL_EQ]);
  ctx.dataL = {};
  ctx.userC = {};
  if (ctx["mod:array/eqno"])
    ctx.userC["label"] = ns.Modules["mod:ref"]["cmd:label:eq"];
}

_Mod.ArrayEnvironmentDefaultPrologue = function(doc, ctx) {
  setupArrayContext(ctx);
  var t = new _at.Table();
  return ctx.ENVDATA = t;

  /*
   * この関数を呼び出した後に、
   *   1. 垂直位置の設定
   *   2. 列の設定
   * 等を必要に応じて行う
   */
};
_Mod.ArrayEnvironmentDefaultEpilogue = function(doc, ctx) {
  var table = ctx.ENVDATA;

  // 最後の出力を拾う
  var last_cont = ctx.output.toHtml();
  if (last_cont.trim().length > 0)
    table.cell().content = last_cont;

  table.write(doc.currentCtx.output);
};

_Mod.ArrayEnvironmentDefaultCatcher = function(doc, ctx) {
  this.epilogue(doc, ctx);
};

_Mod.ArrayEnvironmentMathEpilogue = function(doc, ctx) {
  var table = ctx.ENVDATA;
  table.setSubSup(doc.GetSubSup());
  _Mod.ArrayEnvironmentDefaultEpilogue(doc, ctx);
}

_Mod.ReadVerticalAlign = function(doc) {
  var va = doc.GetOptionalArgumentRaw() || "m";
  if ("tbm".indexOf(va.trim().first()) < 0) {
    doc.currentCtx.output.error(
      'mod:array.env:array.InvalidVerticalAlign', {valign: va});
    va = "m";
  }
  return va;
};

//-----------------------------------------------------------------------------

context "env.array" new("mode.math") {
  _Ctx.AddLetterHandler("&", _at.Table.H_NEXT_COL);
  _Ctx.AddCommandHandler("\\", _at.Table.H_NEXT_ROW);
  _Ctx.AddCommandHandler("hline", _at.Table.H_HLINE);
  _Ctx.AddCommandHandler("cline", _at.Table.H_CLINE);
  _Ctx.AddCommandHandler("multicolumn", _at.Table.H_MULTICOL);
}
_Mod["envdef:array"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    t.valign = _Mod.ReadVerticalAlign(doc); // 第1引数

    // 第二引数 : 水平位置合わせ
    //----------------------------------------------------
    if (doc.scanner.is(mod_core.SCAN_WT_LTR, "{")) {
      doc.scanner.Next();
      var ctx_aln = doc.context_cast(["sub.braced", "env.array.align"]);
      ctx_aln.CTXDATA = new _at.TableAlignSetter(t);
      var err = doc.Read(ctx_aln) || "";
      t.clear_pos(); // (cx,cy) = (0,0)

      // エラーがある場合
      if (err.trim())
        doc.currentCtx.output.buff.push(err);
    } else {
      // ■ alignment 指定開始の括弧がなかった場合
    }

    // 以降の列の追加
    t.default_col().add_bR(ns.Writer.get_error(
      'mod:array.env:array.ExtraColumn'));
  },
  epilogue: _Mod.ArrayEnvironmentDefaultEpilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};
ns.ContextFactory["mode.math"].AddEnvironment("array", _Mod["envdef:array"]);

context "env.tabular" new("mode.para") {
  _Ctx.AddLetterHandler("&", _at.Table.H_NEXT_COL);
  _Ctx.AddCommandHandler("\\", _at.Table.H_NEXT_ROW);
  _Ctx.AddCommandHandler("hline", _at.Table.H_HLINE);
  _Ctx.AddCommandHandler("cline", _at.Table.H_CLINE);
  _Ctx.AddCommandHandler("multicolumn", _at.Table.H_MULTICOL);
}
_Mod["envdef:tabular"] = {
  suppressOutput: true,
  prologue: _Mod["envdef:array"].prologue,
  epilogue: _Mod.ArrayEnvironmentDefaultEpilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.tabular"
};
ns.ContextFactory["mode.para"].AddEnvironment("tabular", _Mod["envdef:tabular"]);

//-----------------------------------------------------------------------------
// 式番号 (eqnarray)

_Mod.eqno_output = function(doc, actx, output) {
  var counter = doc.GetCounter("equation");

  // 式番号
  var buff = output.buff;
  buff.push('<tex:i class="aghtex-eqno-margin"></tex:i>');
  if (actx.dataV[CTXV_EQTAG] || !actx.dataV[CTXV_NOTAG]) {
    buff.push('<tex:i class="aghtex-eqno"><tex:i class="aghtex-eqno-vspan"></tex:i><tex:i class="aghtex-eqno-right">');
    var raisetag = actx.dataV[CTXV_RAISETAG];
    if (raisetag) buff.push('<tex:i class="aghtex-eqno-raise" style="top:', raisetag,';">');

    if (actx.dataV[CTXV_EQTAG]) {
      buff.push(actx.dataV[CTXV_EQTAG]);
    } else if (counter == null) {
      buff.push('(?)');
    } else {
      counter.Step();
      buff.push('(', counter.arabic(), ')');
    }

    if (raisetag) buff.push('</tex:i>');
    buff.push('</tex:i></tex:i>');
  }
  actx.dataV[CTXV_NOTAG] = false;
  actx.dataV[CTXV_EQTAG] = false;
  actx.dataV[CTXV_RAISETAG] = false;

  var labels = actx.GetContextVariable(CTXV_LABEL_EQ);
  if (labels.length > 0) {
    var id = "aghtex." + labels[0];
    for (var i = 1; i < labels.length; i++)
      doc.references.label_id_map[labels[i]] = id;

    buff.push('<a class="aghtex-label" name="', id, '">&nbsp;</a>');
    if (counter != null)
      doc.references.displayedHtml['ref@' + labels[0]] = counter.arabic();

    labels.length = 0;
  }
};

function isEndingEqnoRequired(ctx) {
  if (ctx.ENVDATA.get_current_col() != 0)
    return true;

  var last_cont = ctx.output.toHtml();
  if (last_cont.trim().length > 0)
    return true;

  return false;
}

_Mod.eqno_prologue = function(doc, ctx) {
  ctx["mod:array/eqno"] = true;
  ctx.userC["label"] = ns.Modules["mod:ref"]["cmd:label:eq"];
};
_Mod.eqno_epilogue = function(doc, ctx) {
  if (isEndingEqnoRequired(ctx))
    _Mod.eqno_output(doc, ctx, ctx.output);
};

context "env.eqnarray" new("env.array") {
  _Ctx.DefineCommand("nonumber", ["f", function(doc, argv) {
    doc.AssignContextVariable(CTXV_NOTAG, true);
  }]);
  _Ctx.DefineCommand("\\", ["f;#[]D", function(doc, argv) {
    var output = doc.currentCtx.output;
    var data = _at.Table.GetTable(doc, argv[0], "NextLine");
    if (data == null) return;

    var actx = doc.GetContextVariable(CTXV_ARRAYCTX);
    if (actx != null) {
      _Mod.eqno_output(doc, actx, output);
    } else {
      output.error('mod:array.env:eqnarray.ContextBroken');
    }

    if (argv[1]) data.line().paddingBottom = argv[1];
    data.cell().content += output.toHtml();
    output.clear();

    data.next_row();
  }]);
}

/* 表環境を新しく式番号に対応する為の手順
 * 1. context は "env.eqnarray" またはそれを継承する物である事
 * 2. prologue で以下を記述する事
 *    _Mod.eqno_prologue(doc, ctx);
 * 3. epilogue の処理の前に以下を記述する事
 *    _Mod.eqno_epilogue(doc, ctx);
 */

//-----------------------------------------------------------------------------
// \begin{eqnarray*}
// \begin{eqnarray}

_Mod["envdef:eqnarray*"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    // 列の設定
    t.col(0).halign = "r";
    t.col(1).halign = "c";
    t.col(2).halign = "l";
    t.col(1).paddingL = "0px";
    t.col(1).paddingR = "0px";
    t.default_col().add_bR(ns.Writer.get_error(
      'mod:array.env:eqnarray.ExtraColumn', null,
      "env:eqnarray"));
  },
  epilogue: function(doc, ctx) {
    doc.currentCtx.output.buff.push('<tex:math class="aghtex-displaymath">');
    _Mod.ArrayEnvironmentDefaultEpilogue(doc,ctx);
    doc.currentCtx.output.buff.push('</tex:math>');
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};
_Mod["envdef:eqnarray"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:eqnarray*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_epilogue(doc, ctx);
    _Mod["envdef:eqnarray*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.eqnarray"
};

ns.ContextFactory["mode.para"].AddEnvironment("eqnarray*", _Mod["envdef:eqnarray*"]);
ns.ContextFactory["mode.para"].AddEnvironment("eqnarray", _Mod["envdef:eqnarray"]);

//-----------------------------------------------------------------------------
// amsmath \begin{align*}  (text mode)
// amsmath \begin{align}   (text mode)
// amsmath \begin{aligned} (math mode)

_Mod["envdef:align*"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    // 列の設定
    t.col_hookCreateNew = function(y) {
      var r = _at.Table.prototype.col_hookCreateNew.call(this, y);
      if (y % 2 == 0) {
        r.halign = "r";
        r.paddingR = "0px";
      } else {
        r.halign = "l";
        r.paddingL = "0px";
      }
      return r;
    };
  },
  epilogue: _Mod["envdef:eqnarray*"].epilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

_Mod["envdef:align"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:align*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_epilogue(doc, ctx);
    _Mod["envdef:align*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.eqnarray"
};

_Mod["envdef:aligned"] = {
  suppressOutput: true,
  prologue: _Mod["envdef:align*"].prologue,
  epilogue: _Mod.ArrayEnvironmentMathEpilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

// amsmath \begin{alignat*}  (text mode)
// amsmath \begin{alignat}   (text mode)
// amsmath \begin{alignedat} (math mode)

_Mod["envdef:alignat*"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    var n_ = doc.ReadArgument("txt");
    var n = parseInt(n_);
    if (!(n > 0)) {
      doc.currentCtx.output.error('mod:array.env:alignat.NegativeColumnNumber', {arg1: n_});
    } else for (var i = 0; i < n; i++) {
      t.col(2 * i).halign = "r";
      t.col(2 * i).paddingR = "0px";
      t.col(2 * i + 1).halign = "l";
      t.col(2 * i + 1).paddingL = "0px";
    }

    t.default_col().add_bR(ns.Writer.get_error(
      'mod:array.env:narray.ExtraColumn', null,
      "env:alignat"));
  },
  epilogue: _Mod["envdef:eqnarray*"].epilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

_Mod["envdef:alignat"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:alignat*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_epilogue(doc, ctx);
    _Mod["envdef:alignat*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.eqnarray"
};

_Mod["envdef:alignedat"] = {
  suppressOutput: true,
  prologue: _Mod["envdef:alignat*"].prologue,
  epilogue: _Mod.ArrayEnvironmentMathEpilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

// \begin{flalign*} (amsmath)
// \begin{flalign} (amsmath)

_Mod["envdef:flalign*"] = {
  suppressOutput: true,
  prologue: _Mod["envdef:align*"].prologue,
  epilogue: function(doc, ctx) {
    doc.currentCtx.output.buff.push('<tex:math class="aghtex-flalign">');
    _Mod.ArrayEnvironmentDefaultEpilogue(doc, ctx);
    doc.currentCtx.output.buff.push('</tex:math>');
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

_Mod["envdef:flalign"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:flalign*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_epilogue(doc, ctx);
    _Mod["envdef:flalign*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.eqnarray"
};

// amsmath \begin{gather*}  (text mode)
// amsmath \begin{gather}   (text mode)
// amsmath \begin{gathered} (math mode)

_Mod["envdef:gather*"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    t.col(0).halign = "c";
    t.default_col().add_bR(ns.Writer.get_error(
      'mod:array.env:gather.ExtraColumn', null,
      "env:gather"));
  },
  epilogue: function(doc, ctx) {
    doc.currentCtx.output.buff.push('<tex:math class="aghtex-displaymath">');
    _Mod.ArrayEnvironmentDefaultEpilogue(doc, ctx);
    doc.currentCtx.output.buff.push('</tex:math>');
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

_Mod["envdef:gather"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:gather*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_epilogue(doc, ctx);
    _Mod["envdef:gather*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.eqnarray"
};

_Mod["envdef:gathered"] = {
  suppressOutput: true,
  prologue: _Mod["envdef:gather*"].prologue,
  epilogue: _Mod.ArrayEnvironmentMathEpilogue,
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

// \begin{multline*} (amsmath)
// \begin{multline} (amsmath)

context "env.multline" new("env.array") {
  _Ctx.DefineCommand("nonumber", ['f', function(doc, argv) {
    doc.AssignContextVariable(CTXV_NOTAG, true);
  }]);
}

_Mod["envdef:multline*"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);

    t.col(0).halign = "l";
    t.default_col().add_bR(ns.Writer.get_error(
      'mod:array.env:gather.ExtraColumn', null,
      "env:multline"));
  },
  epilogue: function(doc, ctx) {
    var table = ctx.ENVDATA;

    // 最後の出力を拾う
    var last_cont = ctx.output.toHtml();
    if (last_cont.trim().length > 0)
      table.cell().content = last_cont;

    // padding 設定
    if (table.xM >= 2) {
      for (var x = 1; x < table.xM - 1; x++)
        table.cell(x, 0).paddingL = "4em";
      table.cell(table.xM - 1, 0).paddingL = "8em";
    }

    // 出力
    doc.currentCtx.output.buff.push('<tex:math class="aghtex-displaymath">');
    table.write(doc.currentCtx.output);
    doc.currentCtx.output.buff.push('</tex:math>');
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.array"
};

_Mod["envdef:multline"] = {
  suppressOutput: true,
  prologue: function(doc, ctx) {
    _Mod["envdef:multline*"].prologue(doc, ctx);
    _Mod.eqno_prologue(doc, ctx);
  },
  epilogue: function(doc, ctx) {
    _Mod.eqno_output(doc, ctx, ctx.output);
    _Mod["envdef:multline*"].epilogue(doc, ctx);
  },
  catcher: _Mod.ArrayEnvironmentDefaultCatcher,
  context: "env.multline"
};

//-----------------------------------------------------------------------------
// \begin{matrix} (amsmath)
// \begin{pmatrix} (amsmath)
// \begin{bmatrix} (amsmath)
// \begin{Bmatrix} (amsmath)
// \begin{vmatrix} (amsmath)
// \begin{Vmatrix} (amsmath)

function define_xmatrix(name, bracket) {
  _Mod[name] = {
    suppressOutput: true,
    prologue: function(doc, ctx) {
      var t = _Mod.ArrayEnvironmentDefaultPrologue(doc, ctx);
      t.valign = _Mod.ReadVerticalAlign(doc);
      t.param_bracket = bracket;
      t.default_col().halign = "c";
    },
    epilogue: _Mod.ArrayEnvironmentMathEpilogue,
    catcher: _Mod.ArrayEnvironmentDefaultCatcher,
    context: "env.array"
  };
}

define_xmatrix("envdef:matrix", null);
define_xmatrix("envdef:pmatrix", ["(", ")"]);
define_xmatrix("envdef:bmatrix", ["[", "]"]);
define_xmatrix("envdef:Bmatrix", ["{", "}"]);
define_xmatrix("envdef:vmatrix", ["|", "|"]);
define_xmatrix("envdef:Vmatrix", ["∥", "∥"]);
